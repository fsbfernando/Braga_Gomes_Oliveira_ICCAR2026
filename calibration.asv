clc; close all; clear;

function = calibration()
    % Carrega as imagens de calibração de uma pasta específica
    imageFolder = './Intrinsics/*.png';
    images = imageDatastore(imageFolder);
    
    % Detecta os pontos das bordas do tabuleiro de xadrez nas imagens
    [imagePoints, boardSize] = detectCheckerboardPoints(images.Files);
    
    % Gera as coordenadas do mundo, baseadas no tamanho dos quadrados do tabuleiro
    squareSize = 15; % mm
    worldPoints = generateCheckerboardPoints(boardSize, squareSize);
    
    % Define as combinações de parâmetros para testar
    numRadialDistortionCoefficients = [2, 3];
    estimateSkewOptions = [true, false];
    estimateTangentialDistortionOptions = [true, false];
    
    % Inicializa uma estrutura para armazenar os resultados
    results = struct();
    counter = 0;
    
    % Testa todas as combinações de parâmetros definidos acima
    for radialCoeffs = numRadialDistortionCoefficients
        for skewOption = estimateSkewOptions
            for tangOption = estimateTangentialDistortionOptions
                counter = counter + 1;
                
                % Exibe a combinação de parâmetros que está sendo testada
                fprintf('\nTesting combination %d:\n', counter);
                fprintf('RadialCoeffs: %d, Skew: %d, Tangential: %d\n', ...
                        radialCoeffs, skewOption, tangOption);
                
                % Calibração inicial usando todas as imagens
                goodImages = true(1, size(imagePoints, 3));
                params = estimateCameraParameters(imagePoints(:,:,goodImages), worldPoints, ...
                    'ImageSize', [size(readimage(images,1), 1), size(readimage(images,1), 2)], ...
                    'NumRadialDistortionCoefficients', radialCoeffs, ...
                    'EstimateSkew', skewOption, ...
                    'EstimateTangentialDistortion', tangOption);
                
                % Erro inicial de reprojeção (quanto a calibração está "desajustada")
                initialError = params.MeanReprojectionError;
                
                % Iterações de remoção de outliers (remover as 7 imagens com piores erros de reprojeção)
                numIterations = 3;
                for iter = 1:numIterations
                    reprojErrors = params.ReprojectionErrors;
                    meanErrors = calculateMeanReprojectionErrors(reprojErrors);
                    
                    % Encontra a imagem com o maior erro médio e a marca como "ruim"
                    [~, worstIdx] = max(meanErrors);
                    validImageIdx = find(goodImages);
                    worstIdxValid = validImageIdx(worstIdx);
                    goodImages(worstIdxValid) = false;
                    
                    % Recalibra os parâmetros sem a imagem "ruim"
                    params = estimateCameraParameters(imagePoints(:,:,goodImages), worldPoints, ...
                        'ImageSize', params.ImageSize, ...
                        'NumRadialDistortionCoefficients', radialCoeffs, ...
                        'EstimateSkew', skewOption, ...
                        'EstimateTangentialDistortion', tangOption);
                end
                
                % Armazena os resultados da calibração para essa combinação de parâmetros
                results(counter).RadialCoeffs = radialCoeffs;
                results(counter).EstimateSkew = skewOption;
                results(counter).EstimateTangentialDistortion = tangOption;
                results(counter).InitialError = initialError;
                results(counter).FinalError = params.MeanReprojectionError;
                results(counter).Params = params;
                results(counter).ImagesUsed = find(goodImages);
                
                % Exibe os erros iniciais e finais após a remoção de outliers
                fprintf('Initial error: %.4f pixels\n', initialError);
                fprintf('Final error after outlier removal: %.4f pixels\n', params.MeanReprojectionError);
                fprintf('Images kept: %d/%d\n', sum(goodImages), numel(images.Files));
            end
        end
    end
    
    % Encontra a melhor combinação de parâmetros com o menor erro final
    [bestError, bestIdx] = min([results.FinalError]);
    disp([results.FinalError])
    bestParams = results(bestIdx).Params;
    
    % Exibe os resultados da melhor combinação
    fprintf('\n=== BEST COMBINATION ===\n');
    fprintf('RadialCoeffs: %d, Skew: %d, Tangential: %d\n', ...
            results(bestIdx).RadialCoeffs, ...
            results(bestIdx).EstimateSkew, ...
            results(bestIdx).EstimateTangentialDistortion);
    fprintf('Initial error: %.4f pixels\n', results(bestIdx).InitialError);
    fprintf('Final error: %.4f pixels\n', bestError);
    fprintf('Images used: %s\n', mat2str(results(bestIdx).ImagesUsed));
    
    % Salva os melhores parâmetros encontrados e todos os resultados das calibrações
    save('./data/bestCameraParams.mat', 'bestParams');
    
    % Exibe os erros de reprojeção para a melhor combinação de parâmetros
    figure;
    showReprojectionErrors(bestParams);
    title(sprintf('Best Combination (Error: %.4f pixels)', bestError));

end
% Função auxiliar para calcular os erros de reprojeção médios, ignorando NaN e zeros
function meanErrors = calculateMeanReprojectionErrors(reprojErrors)
    % Função para calcular a média dos erros de reprojeção,
    % ignorando valores NaN e zeros, para cada imagem.

    % Inicializando o vetor para armazenar os erros médios
    meanErrors = zeros(1, size(reprojErrors, 3));  
    
    % Loop sobre cada imagem
    for imgIdx = 1:size(reprojErrors, 3)
        % Extrair os erros de reprojeção para a imagem imgIdx
        imageErrors = reprojErrors(:, :, imgIdx);
        
        % Identificar onde há NaN ou zero (não válidos)
        validMask = ~(isnan(imageErrors(:, 1)) | isnan(imageErrors(:, 2)) | imageErrors(:, 1) == 0 | imageErrors(:, 2) == 0);
        
        % Calcular a soma dos erros válidos
        validErrors = sqrt(sum(imageErrors(validMask, :).^2, 2)); 
        
        % Calcular a média dividindo pela quantidade de valores válidos
        meanErrors(imgIdx) = sum(validErrors) / sum(validMask);  
    end
end
